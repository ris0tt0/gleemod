/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/js-logger/src/logger.js":
/*!**********************************************!*\
  !*** ./node_modules/js-logger/src/logger.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\r\n * js-logger - http://github.com/jonnyreeves/js-logger\r\n * Jonny Reeves, http://jonnyreeves.co.uk/\r\n * js-logger may be freely distributed under the MIT license.\r\n */\r\n(function (global) {\r\n\t\"use strict\";\r\n\r\n\t// Top level module for the global, static logger instance.\r\n\tvar Logger = { };\r\n\r\n\t// For those that are at home that are keeping score.\r\n\tLogger.VERSION = \"1.6.0\";\r\n\r\n\t// Function which handles all incoming log messages.\r\n\tvar logHandler;\r\n\r\n\t// Map of ContextualLogger instances by name; used by Logger.get() to return the same named instance.\r\n\tvar contextualLoggersByNameMap = {};\r\n\r\n\t// Polyfill for ES5's Function.bind.\r\n\tvar bind = function(scope, func) {\r\n\t\treturn function() {\r\n\t\t\treturn func.apply(scope, arguments);\r\n\t\t};\r\n\t};\r\n\r\n\t// Super exciting object merger-matron 9000 adding another 100 bytes to your download.\r\n\tvar merge = function () {\r\n\t\tvar args = arguments, target = args[0], key, i;\r\n\t\tfor (i = 1; i < args.length; i++) {\r\n\t\t\tfor (key in args[i]) {\r\n\t\t\t\tif (!(key in target) && args[i].hasOwnProperty(key)) {\r\n\t\t\t\t\ttarget[key] = args[i][key];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn target;\r\n\t};\r\n\r\n\t// Helper to define a logging level object; helps with optimisation.\r\n\tvar defineLogLevel = function(value, name) {\r\n\t\treturn { value: value, name: name };\r\n\t};\r\n\r\n\t// Predefined logging levels.\r\n\tLogger.TRACE = defineLogLevel(1, 'TRACE');\r\n\tLogger.DEBUG = defineLogLevel(2, 'DEBUG');\r\n\tLogger.INFO = defineLogLevel(3, 'INFO');\r\n\tLogger.TIME = defineLogLevel(4, 'TIME');\r\n\tLogger.WARN = defineLogLevel(5, 'WARN');\r\n\tLogger.ERROR = defineLogLevel(8, 'ERROR');\r\n\tLogger.OFF = defineLogLevel(99, 'OFF');\r\n\r\n\t// Inner class which performs the bulk of the work; ContextualLogger instances can be configured independently\r\n\t// of each other.\r\n\tvar ContextualLogger = function(defaultContext) {\r\n\t\tthis.context = defaultContext;\r\n\t\tthis.setLevel(defaultContext.filterLevel);\r\n\t\tthis.log = this.info;  // Convenience alias.\r\n\t};\r\n\r\n\tContextualLogger.prototype = {\r\n\t\t// Changes the current logging level for the logging instance.\r\n\t\tsetLevel: function (newLevel) {\r\n\t\t\t// Ensure the supplied Level object looks valid.\r\n\t\t\tif (newLevel && \"value\" in newLevel) {\r\n\t\t\t\tthis.context.filterLevel = newLevel;\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\t// Gets the current logging level for the logging instance\r\n\t\tgetLevel: function () {\r\n\t\t\treturn this.context.filterLevel;\r\n\t\t},\r\n\r\n\t\t// Is the logger configured to output messages at the supplied level?\r\n\t\tenabledFor: function (lvl) {\r\n\t\t\tvar filterLevel = this.context.filterLevel;\r\n\t\t\treturn lvl.value >= filterLevel.value;\r\n\t\t},\r\n\r\n\t\ttrace: function () {\r\n\t\t\tthis.invoke(Logger.TRACE, arguments);\r\n\t\t},\r\n\r\n\t\tdebug: function () {\r\n\t\t\tthis.invoke(Logger.DEBUG, arguments);\r\n\t\t},\r\n\r\n\t\tinfo: function () {\r\n\t\t\tthis.invoke(Logger.INFO, arguments);\r\n\t\t},\r\n\r\n\t\twarn: function () {\r\n\t\t\tthis.invoke(Logger.WARN, arguments);\r\n\t\t},\r\n\r\n\t\terror: function () {\r\n\t\t\tthis.invoke(Logger.ERROR, arguments);\r\n\t\t},\r\n\r\n\t\ttime: function (label) {\r\n\t\t\tif (typeof label === 'string' && label.length > 0) {\r\n\t\t\t\tthis.invoke(Logger.TIME, [ label, 'start' ]);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\ttimeEnd: function (label) {\r\n\t\t\tif (typeof label === 'string' && label.length > 0) {\r\n\t\t\t\tthis.invoke(Logger.TIME, [ label, 'end' ]);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t// Invokes the logger callback if it's not being filtered.\r\n\t\tinvoke: function (level, msgArgs) {\r\n\t\t\tif (logHandler && this.enabledFor(level)) {\r\n\t\t\t\tlogHandler(msgArgs, merge({ level: level }, this.context));\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t// Protected instance which all calls to the to level `Logger` module will be routed through.\r\n\tvar globalLogger = new ContextualLogger({ filterLevel: Logger.OFF });\r\n\r\n\t// Configure the global Logger instance.\r\n\t(function() {\r\n\t\t// Shortcut for optimisers.\r\n\t\tvar L = Logger;\r\n\r\n\t\tL.enabledFor = bind(globalLogger, globalLogger.enabledFor);\r\n\t\tL.trace = bind(globalLogger, globalLogger.trace);\r\n\t\tL.debug = bind(globalLogger, globalLogger.debug);\r\n\t\tL.time = bind(globalLogger, globalLogger.time);\r\n\t\tL.timeEnd = bind(globalLogger, globalLogger.timeEnd);\r\n\t\tL.info = bind(globalLogger, globalLogger.info);\r\n\t\tL.warn = bind(globalLogger, globalLogger.warn);\r\n\t\tL.error = bind(globalLogger, globalLogger.error);\r\n\r\n\t\t// Don't forget the convenience alias!\r\n\t\tL.log = L.info;\r\n\t}());\r\n\r\n\t// Set the global logging handler.  The supplied function should expect two arguments, the first being an arguments\r\n\t// object with the supplied log messages and the second being a context object which contains a hash of stateful\r\n\t// parameters which the logging function can consume.\r\n\tLogger.setHandler = function (func) {\r\n\t\tlogHandler = func;\r\n\t};\r\n\r\n\t// Sets the global logging filter level which applies to *all* previously registered, and future Logger instances.\r\n\t// (note that named loggers (retrieved via `Logger.get`) can be configured independently if required).\r\n\tLogger.setLevel = function(level) {\r\n\t\t// Set the globalLogger's level.\r\n\t\tglobalLogger.setLevel(level);\r\n\r\n\t\t// Apply this level to all registered contextual loggers.\r\n\t\tfor (var key in contextualLoggersByNameMap) {\r\n\t\t\tif (contextualLoggersByNameMap.hasOwnProperty(key)) {\r\n\t\t\t\tcontextualLoggersByNameMap[key].setLevel(level);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\t// Gets the global logging filter level\r\n\tLogger.getLevel = function() {\r\n\t\treturn globalLogger.getLevel();\r\n\t};\r\n\r\n\t// Retrieve a ContextualLogger instance.  Note that named loggers automatically inherit the global logger's level,\r\n\t// default context and log handler.\r\n\tLogger.get = function (name) {\r\n\t\t// All logger instances are cached so they can be configured ahead of use.\r\n\t\treturn contextualLoggersByNameMap[name] ||\r\n\t\t\t(contextualLoggersByNameMap[name] = new ContextualLogger(merge({ name: name }, globalLogger.context)));\r\n\t};\r\n\r\n\t// CreateDefaultHandler returns a handler function which can be passed to `Logger.setHandler()` which will\r\n\t// write to the window's console object (if present); the optional options object can be used to customise the\r\n\t// formatter used to format each log message.\r\n\tLogger.createDefaultHandler = function (options) {\r\n\t\toptions = options || {};\r\n\r\n\t\toptions.formatter = options.formatter || function defaultMessageFormatter(messages, context) {\r\n\t\t\t// Prepend the logger's name to the log message for easy identification.\r\n\t\t\tif (context.name) {\r\n\t\t\t\tmessages.unshift(\"[\" + context.name + \"]\");\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// Map of timestamps by timer labels used to track `#time` and `#timeEnd()` invocations in environments\r\n\t\t// that don't offer a native console method.\r\n\t\tvar timerStartTimeByLabelMap = {};\r\n\r\n\t\t// Support for IE8+ (and other, slightly more sane environments)\r\n\t\tvar invokeConsoleMethod = function (hdlr, messages) {\r\n\t\t\tFunction.prototype.apply.call(hdlr, console, messages);\r\n\t\t};\r\n\r\n\t\t// Check for the presence of a logger.\r\n\t\tif (typeof console === \"undefined\") {\r\n\t\t\treturn function () { /* no console */ };\r\n\t\t}\r\n\r\n\t\treturn function(messages, context) {\r\n\t\t\t// Convert arguments object to Array.\r\n\t\t\tmessages = Array.prototype.slice.call(messages);\r\n\r\n\t\t\tvar hdlr = console.log;\r\n\t\t\tvar timerLabel;\r\n\r\n\t\t\tif (context.level === Logger.TIME) {\r\n\t\t\t\ttimerLabel = (context.name ? '[' + context.name + '] ' : '') + messages[0];\r\n\r\n\t\t\t\tif (messages[1] === 'start') {\r\n\t\t\t\t\tif (console.time) {\r\n\t\t\t\t\t\tconsole.time(timerLabel);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\ttimerStartTimeByLabelMap[timerLabel] = new Date().getTime();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tif (console.timeEnd) {\r\n\t\t\t\t\t\tconsole.timeEnd(timerLabel);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tinvokeConsoleMethod(hdlr, [ timerLabel + ': ' +\r\n\t\t\t\t\t\t\t(new Date().getTime() - timerStartTimeByLabelMap[timerLabel]) + 'ms' ]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\t// Delegate through to custom warn/error loggers if present on the console.\r\n\t\t\t\tif (context.level === Logger.WARN && console.warn) {\r\n\t\t\t\t\thdlr = console.warn;\r\n\t\t\t\t} else if (context.level === Logger.ERROR && console.error) {\r\n\t\t\t\t\thdlr = console.error;\r\n\t\t\t\t} else if (context.level === Logger.INFO && console.info) {\r\n\t\t\t\t\thdlr = console.info;\r\n\t\t\t\t} else if (context.level === Logger.DEBUG && console.debug) {\r\n\t\t\t\t\thdlr = console.debug;\r\n\t\t\t\t} else if (context.level === Logger.TRACE && console.trace) {\r\n\t\t\t\t\thdlr = console.trace;\r\n\t\t\t\t}\r\n\r\n\t\t\t\toptions.formatter(messages, context);\r\n\t\t\t\tinvokeConsoleMethod(hdlr, messages);\r\n\t\t\t}\r\n\t\t};\r\n\t};\r\n\r\n\t// Configure and example a Default implementation which writes to the `window.console` (if present).  The\r\n\t// `options` hash can be used to configure the default logLevel and provide a custom message formatter.\r\n\tLogger.useDefaults = function(options) {\r\n\t\tLogger.setLevel(options && options.defaultLevel || Logger.DEBUG);\r\n\t\tLogger.setHandler(Logger.createDefaultHandler(options));\r\n\t};\r\n\r\n\t// Export to popular environments boilerplate.\r\n\tif (true) {\r\n\t\t!(__WEBPACK_AMD_DEFINE_FACTORY__ = (Logger),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t}\r\n\telse {}\r\n}(this));\r\n\n\n//# sourceURL=webpack:///./node_modules/js-logger/src/logger.js?");

/***/ }),

/***/ "./src/cell.js":
/*!*********************!*\
  !*** ./src/cell.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// const Logger = require('js-logger');\n\nmodule.exports = class\n{\n\tconstructor(type)\n\t{\n\t\t// Logger.info(`Cell::constructor type:${type}`);\n\n\t\tthis.cellType = type;\n\t}\n};\n\n//# sourceURL=webpack:///./src/cell.js?");

/***/ }),

/***/ "./src/controller.js":
/*!***************************!*\
  !*** ./src/controller.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Logger = __webpack_require__(/*! js-logger */ \"./node_modules/js-logger/src/logger.js\");\nconst Model = __webpack_require__(/*! ./model */ \"./src/model.js\");\n\nmodule.exports = class\n{\n\t/**\n\t * CTOR\n\t * @param {int} columns The total number of columns\n\t * @param {int} rows The total number of rows\n\t * @param {Array} itemTypes A list of available cell item types\n\t */\n\tconstructor(model = new Model)\n\t{\n\t\tLogger.info('controller::constructor');\n\t\tthis.model = model;\n\n\t\tthis.init();\n\t}\n\n\t/**\n\t * Initialize the class.\n\t */\n\tinit()\n\t{\n\t\tLogger.info('controller::init');\n\t}\n\n\t/**\n\t * Swap cells in either TOP,BOTTOM,LEFT,RIGHT directions\n\t * \n\t * @param {int} column The column coord\n\t * @param {int} row The row coord\n\t * @param {string} direction A direction in which to swap the (column,row)\n\t */\n\tswap(column,row,direction)\n\t{\n\t\tlet x = column;\n\t\tlet y = row;\n\t\t\n\t\tswitch(direction.toLowerCase())\n\t\t{\n\t\tcase 'top':\n\t\t\t--y;\n\t\t\tbreak;\n\t\tcase 'bottom':\n\t\t\t++y;\n\t\t\tbreak;\n\t\tcase 'left':\n\t\t\t++x;\n\t\t\tbreak;\n\t\tcase 'right':\n\t\t\t--x;\n\t\t\tbreak;\n\t\t}\n\n\t\tthis.model.swap(column,row,x,y);\n\t}\n\n\t// checkForMatches()\n\t// {\n\t// \tconst retVal = this.findMatches( this.model.getMatches());\n\t// \t// Logger.info(retVal);\n\t// \treturn  retVal;\n\t// }\n\n\tgetBoardColumnList()\n\t{\n\t\treturn this.model.getBoardColumnList();\n\t}\n\n\tgetBoardColumn(columnIndex)\n\t{\n\t\treturn this.model.getColumn(columnIndex);\n\t}\n\n\tgetBoardColumnType(columnIndex)\n\t{\n\t\treturn this.model.getColumnType(columnIndex);\n\t}\n\n\t/**\n\t * view controller.swaps(column,row)\n\t * view controller.getMatches()\n\t * MAP\n\t * keys are columns\n\t * value: {\n\t * \t\tcolumn[1,2,3,4],\n\t * \t\treplacedIndices[1,2,3],\n\t * \t\t}\n\t * \n\t */\n\n\tgetMatchesForColumnMap(columnMap)\n\t{\n\t\tlet entry,entry2,rows;\n\n\t\tconst retVal = new Map();\n\n\t\tfor(entry of columnMap.entries())\n\t\t{\n\t\t\t// entry[0] is the column\n\t\t\trows = [];\t\n\t\t\tfor(entry2 of entry[1])\n\t\t\t{\n\t\t\t\t// cell type that was found. for now ignore.\n\t\t\t\t// entry2[0]\n\t\t\t\trows.push(entry2[1]);\n\t\t\t}\n\n\t\t\tif(!retVal.get(entry[0])) retVal.set(entry[0],{indices:[],replace:[]});\n\t\t\tretVal.get(entry[0]).indices = this.model.flattenList(rows);\n\t\t}\n\n\t\treturn retVal;\n\t}\n\n\tgetMatchesForRowMap(rowMap)\n\t{\n\t\tconst retVal = new Map();\n\t\tlet entry,entry2,cols,map;\n\t\tfor(entry of rowMap.entries())\n\t\t{\n\t\t\tcols = [];\n\t\t\t// entry[0] is the row\n\t\t\tfor(entry2 of entry[1])\n\t\t\t{\n\t\t\t\t// cell type is entry2[0]\n\t\t\t\tcols.push(entry2[1]);\n\t\t\t}\n\t\t\tcols = this.model.flattenList(cols);\n\t\t\t// Logger.info(entry[0],cols);\n\t\t\tfor( let colIndex of cols)\n\t\t\t{\n\t\t\t\tif(!retVal.get(colIndex))\n\t\t\t\t{\n\t\t\t\t\tretVal.set(colIndex,{indices:[],replace:[]});\n\t\t\t\t}\n\t\t\t\tmap = retVal.get(colIndex);\n\t\t\t\tif( map.indices.indexOf(entry[0]) < 0)\n\t\t\t\t\tmap.indices.push(entry[0]);\n\t\t\t}\n\t\t}\n\t\treturn retVal;\n\t}\n\n\tgetMatches()\n\t{\n\t\t// const {columnMap,rowMap} = this.model.getMatches();\n\n\t\t// const retVal = new Map(\n\t\t// \tthis.getMatchesForColumnMap(columnMap),\n\t\t// \tthis.getMatchesForRowMap(rowMap));\n\n\t\tconst retVal = new Map();\n\t\tconst {columnMap,rowMap} = this.model.getMatches();\n\t\tlet rows,cols,entry,entry2,map;\n\n\t\tfor(entry of columnMap.entries())\n\t\t{\n\t\t\t// entry[0] is the column\n\t\t\trows = [];\t\n\t\t\tfor(entry2 of entry[1])\n\t\t\t{\n\t\t\t\t// cell type that was found. for now ignore.\n\t\t\t\t// entry2[0]\n\t\t\t\trows.push(entry2[1]);\n\t\t\t}\n\n\t\t\tif(!retVal.get(entry[0])) retVal.set(entry[0],{indices:[],replace:[]});\n\t\t\tretVal.get(entry[0]).indices = this.model.flattenList(rows);\n\t\t}\n\n\t\tfor(entry of rowMap.entries())\n\t\t{\n\t\t\tcols = [];\n\t\t\t// entry[0] is the row\n\t\t\tfor(entry2 of entry[1])\n\t\t\t{\n\t\t\t\t// cell type is entry2[0]\n\t\t\t\tcols.push(entry2[1]);\n\t\t\t}\n\t\t\tcols = this.model.flattenList(cols);\n\t\t\t// Logger.info(entry[0],cols);\n\t\t\tfor( let colIndex of cols)\n\t\t\t{\n\t\t\t\tif(!retVal.get(colIndex))\n\t\t\t\t{\n\t\t\t\t\tretVal.set(colIndex,{indices:[],replace:[]});\n\t\t\t\t}\n\t\t\t\tmap = retVal.get(colIndex);\n\t\t\t\tif( map.indices.indexOf(entry[0]) < 0)\n\t\t\t\t\tmap.indices.push(entry[0]);\n\t\t\t}\n\t\t}\n\t\t// orgainize\n\t\tfor(entry of retVal.entries())\n\t\t{\n\t\t\tlet indices = entry[1].indices;\n\t\t\t// sort the removed index\n\t\t\tindices.sort();\n\t\t\t// get current column\n\t\t\tlet column = this.model.getColumnType(entry[0]);\n\t\t\tentry[1].oldColumn = column.concat();\n\t\t\t// get replacement cell types.\n\t\t\tlet replace = this.model.getRandomCellTypesList(\n\t\t\t\tentry[1].indices.length,\n\t\t\t\tthis.model.itemTypes);\n\t\t\t// remove the items from the column\n\t\t\tthis.model.removeIndicesFromList(indices,column);\n\t\t\t// new cell types\n\t\t\tentry[1].replace = replace;\n\t\t\t// new column data with replaced on top.\n\t\t\tentry[1].column = [...replace,...column];\n\n\t\t\tthis.model.updateColumnType(entry[0],entry[1].column);\n\t\t}\n\t\t\n\t\treturn retVal;\n\t}\n};\n\n//# sourceURL=webpack:///./src/controller.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: Controller, Cell, Model */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _controller__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./controller */ \"./src/controller.js\");\n/* harmony import */ var _controller__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_controller__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"Controller\", function() { return _controller__WEBPACK_IMPORTED_MODULE_0___default.a; });\n/* harmony import */ var _cell__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cell */ \"./src/cell.js\");\n/* harmony import */ var _cell__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_cell__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"Cell\", function() { return _cell__WEBPACK_IMPORTED_MODULE_1___default.a; });\n/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./model */ \"./src/model.js\");\n/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_model__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, \"Model\", function() { return _model__WEBPACK_IMPORTED_MODULE_2___default.a; });\nconst Logger = __webpack_require__(/*! js-logger */ \"./node_modules/js-logger/src/logger.js\");\n// const Controller = require('./controller');\n\n\n\n\n\n\n// module.exports = {Controller};\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/model.js":
/*!**********************!*\
  !*** ./src/model.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Logger = __webpack_require__(/*! js-logger */ \"./node_modules/js-logger/src/logger.js\");\nconst Cell = __webpack_require__(/*! ./cell */ \"./src/cell.js\");\n\nmodule.exports = class\n{\n\tconstructor(row = 0,column = 0,matchLimit = 3,itemTypes = [],items = [])\n\t{\n\t\tLogger.info('model::constructor');\n\n\t\t/**\n\t\t * Total number of rows\n\t\t */\n\t\tthis.rows = row;\n\t\t/**\n\t\t * Total number of columns\n\t\t */\n\t\tthis.columns = column;\n\t\t/**\n\t\t * Match limit, default is 3.\n\t\t */\n\t\tthis.matchLimit = matchLimit;\n\t\t/** \n\t\t * The different Item types\n\t\t */\n\t\tthis.itemTypes = itemTypes;\n\t\t/**\n\t\t * A list of items\n\t\t */\n\t\tthis.items = items;\n\n\t\tif( this.items.length === 0)\n\t\t{\n\t\t\tLogger.info('items.length is 0');\n\t\t\tthis.init();\n\t\t}\n\n\t\tif( this.rows * this.columns !== this.items.length)\n\t\t{\n\t\t\tLogger.info(`rows ${this.rows} columns ${this.columns}`);\n\t\t\tlet expected = this.rows * this.columns;\n\t\t\tthrow new Error(`Mismatched rows*columns: ${expected} item.length:${this.items.length}`);\n\t\t}\n\t}\n\n\t/**\n\t * Initializes the model\n\t */\n\tinit()\n\t{\n\t\tthis.initBoard();\n\t\tthis.randomizeBoardItemCellTypes();\n\t}\n\n\t/**\n\t * Initialize the board\n\t */\n\tinitBoard()\n\t{\n\t\tLogger.info('model::initboard');\n\n\t\tthis.items = new Array(this.rows*this.columns);\n\t\t// fill the array with items needed\n\t\tfor(let i = 0; i < this.items.length; ++i)\n\t\t{\n\t\t\tthis.items[i] = new Cell();\n\t\t}\n\t}\n\n\t/**\n\t * Returns a Cell reference from the provided coords.\n\t * \n\t * @param {int} columnIndex The X coord\n\t * @param {int} rowIndex The Y coord\n\t */\n\tgetItemByCoords(columnIndex,rowIndex)\n\t{\n\t\tconst index = columnIndex + rowIndex * this.columns;\n\t\t\n\t\treturn this.items[index];\n\t}\n\n\t/**\n\t * Returns the coord for the provided Cell instance.s\n\t * @param {Cell} cell \n\t */\n\tgetItemCoord(cell)\n\t{\n\t\tconst index = this.items.indexOf(cell);\n\t\tLogger.info(`model::getItemCoord ${index}`);\n\n\t\treturn this.getItemCoordByIndex(index);\n\t}\n\n\t/**\n\t * Returns the coord for the provided index.\n\t * @param {int} index \n\t */\n\tgetItemCoordByIndex(index)\n\t{\n\t\tlet x = index % (this.columns);\n\t\tlet y = Math.floor(index/(this.columns));\n\n\t\treturn {x,y};\n\t}\n\n\t/**\n\t * Returns the column list.\n\t * @param {int} columnIndex \n\t */\n\tgetColumn(columnIndex)\n\t{\n\t\tconst column = [];\n\n\t\tfor(let rowIndex = 0; rowIndex<this.rows; rowIndex++)\n\t\t{\n\t\t\tcolumn.push(this.getItemByCoords(columnIndex,rowIndex));\n\t\t}\n\n\t\treturn column;\n\t}\n\n\tgetColumnType(columnIndex)\n\t{\n\t\tconst column = [];\n\n\t\tfor(let rowIndex = 0; rowIndex<this.rows; rowIndex++)\n\t\t{\n\t\t\tcolumn.push(this.getItemByCoords(columnIndex,rowIndex).cellType);\n\t\t}\n\n\t\treturn column;\n\t}\n\n\tupdateColumnType(column,itemTypes)\n\t{\n\t\tfor(let entry of itemTypes.entries())\n\t\t{\n\t\t\tlet index = entry[0];\n\t\t\tlet type = entry[1];\n\t\t\t\n\t\t\tthis.getColumn(column)[index].cellType = type;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the row list.\n\t * @param {int} rowIndex \n\t */\n\tgetRow(rowIndex)\n\t{\n\t\tconst row = [];\n\n\t\tfor(let columnIndex = 0; columnIndex < this.columns; ++columnIndex)\n\t\t{\n\t\t\trow.push(this.getItemByCoords(columnIndex,rowIndex));\n\t\t}\n\n\t\treturn row;\n\t}\n\n\t/**\n\t * Returns a list that contains columns in order.\n\t */\n\tgetBoardColumnList()\n\t{\n\t\tconst board = [];\n\n\t\tfor(let i = 0; i<this.columns; i++)\n\t\t{\n\t\t\tboard.push(this.getColumn(i));\n\t\t}\n\t\t\n\t\treturn board;\n\t}\n\n\t/**\n\t * Method to return an array list containing a random\n\t * amount of itemTypes.\n\t * \n\t * @param {int} length Total length of returned array list\n\t * @param {Array} itemTypes List of items to be randomized in the \n\t * returned list.\n\t */\n\tgetRandomCellTypesList(length,itemTypes)\n\t{\n\t\t// const retVal = new Array(length);\n\t\tconst typeAmountLimit = Math.floor(length/itemTypes.length);\n\t\tlet randomItems = [];\n\n\t\tfor( let type of itemTypes.values())\n\t\t{\n\t\t\trandomItems.push(new Array(typeAmountLimit).fill(type));\n\t\t}\n\n\t\trandomItems = this.flattenList(randomItems);\n\t\tconst oldLength = randomItems.length;\n\n\t\t// set the list to correct legnth;\n\t\trandomItems.length = length;\n\t\t// shore up the end with pseudo random\n\t\trandomItems.fill(\n\t\t\titemTypes[Math.floor(Math.random() * itemTypes.length)],\n\t\t\toldLength);\n\n\t\tthis.shuffleList(randomItems);\n\n\t\treturn randomItems;\n\t}\n\n\t/**\n\t * Radomizes each item's cell type in the game board.\n\t */\n\trandomizeBoardItemCellTypes()\n\t{\n\t\tthis.randomizeItems(this.items,this.itemTypes);\n\t}\n\t/**\n\t * Randomizes items:Cell[]\n\t * \n\t * @param {Array} items \n\t * @param {Array} itemTypes \n\t */\n\trandomizeItems(items,itemTypes)\n\t{\n\t\tlet randomItems = this.getRandomCellTypesList(items.length,itemTypes);\n\n\t\tfor( let entry of items.entries())\n\t\t{\n\t\t\tentry[1].cellType = randomItems[entry[0]];\n\t\t}\n\t}\n\n\t/**\n\t * Flattens an array list.\n\t * \n\t * @param {Array} input \n\t */\n\tflattenList(input)\n\t{\n\t\tconst stack = [...input];\n\t\tconst retVal = [];\n\t\twhile (stack.length)\n\t\t{\n\t\t\tconst next = stack.pop();\n\t\t\tif (Array.isArray(next))\n\t\t\t{\n\t\t\t\tstack.push(...next);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tretVal.push(next);\n\t\t\t}\n\t\t}\n\t\treturn retVal.reverse();\n\t}\n\n\t/**\n\t * Suffles items within an array list.\n\t * @param {Array} list \n\t */\n\tshuffleList(list)\n\t{\n\t\tfor (let i = list.length - 1; i > 0; i--)\n\t\t{\n\t\t\tconst j = Math.floor(Math.random() * (i + 1));\n\t\t\t[list[i], list[j]] = [list[j], list[i]];\n\t\t}\n\t}\n\n\t/**\n\t * Finds and swaps cell types from the provided coords\n\t * \n\t * @param {int} column1 item 1 x value\n\t * @param {int} row1 item 1 y value\n\t * @param {int} column2 item 2 x coord\n\t * @param {int} row2 item 2 y coord\n\t */\n\tswap(column1,row1,column2,row2)\n\t{\n\t\t/** TODO create and use setItem method\n\t\t * if more values are needed\n\t\t*/\n\t\tconst item1 = this.getItemByCoords(column1,row1);\n\t\tconst item2 = this.getItemByCoords(column2,row2);\n\n\t\tif(item1 && item2)\n\t\t{\n\t\t\t// store value\n\t\t\tconst type = item1.cellType;\n\t\t\t// swap item1 with item2\n\t\t\titem1.cellType = item2.cellType;\n\t\t\t// restore saved value\n\t\t\titem2.cellType = type;\n\t\t}\n\t}\n\n\t/**\n\t * Searches game board and returns any matches\n\t */\n\tgetMatches()\n\t{\n\t\tlet i,map,rowList,columnList;\n\t\t\n\t\tconst rowMap = new Map();\n\t\tconst columnMap = new Map();\n\n\t\tfor(i = 0; i<this.columns;++i)\n\t\t{\n\t\t\tcolumnList = this.getColumn(i);\n\t\t\tmap = this.searchList(columnList);\n\t\t\tif( map.size > 0) columnMap.set(i,map);\n\n\t\t}\n\t\t\n\t\tfor(i = 0; i<this.rows;++i)\n\t\t{\n\t\t\trowList = this.getRow(i);\n\t\t\tmap = this.searchList(rowList);\n\t\t\tif(map.size > 0) rowMap.set(i,map);\n\t\t}\n\n\t\treturn {columnMap,rowMap};\n\t}\n\n\t/**\n\t * Searches through a list to find items that have\n\t * the same celltype.\n\t * \n\t * Returns a Map\n\t */\n\tsearchList(list)\n\t{\n\t\tlet c1,c2,a,i;\n\t\tconst retVal = new Map();\n\n\t\ta = [];\n\t\tfor(i = 0;i<list.length;i++)\n\t\t{\n\t\t\tc1 = list[i];\n\t\t\tc2 = list[i+1];\n\t\t\tif(c2 && c1.cellType === c2.cellType)\n\t\t\t{\n\t\t\t\ta.push(i);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(list[i-1] && list[i].cellType === list[i-1].cellType)\n\t\t\t\t{\n\t\t\t\t\ta.push(i);\n\t\t\t\t}\n\t\t\t\tif( a.length > this.matchLimit - 1)\n\t\t\t\t{\n\t\t\t\t\tif(!retVal.has(c1.cellType))\n\t\t\t\t\t{\n\t\t\t\t\t\tretVal.set(c1.cellType,[]);\n\t\t\t\t\t}\n\t\t\t\t\tretVal.get(c1.cellType).push(a);\n\t\t\t\t}\n\t\t\t\ta = [];\n\t\t\t}\n\t\t}\n\n\t\treturn retVal;\n\t}\n\n\t/**\n\t * Removes items from array list.\n\t * @param {Array} indices Index list to remove.\n\t * @param {Array} list Array list to remove from.\n\t */\n\tremoveIndicesFromList(indices,list)\n\t{\n\t\t// indices.concat().reverse().map(i => list.splice(i,1));\n\t\t// copy\n\t\t// [2,3]\n\t\t// reverse\n\t\t// [3,2]\n\t\tindices.concat().reverse().map(index => list.splice(index,1));\n\t}\n};\n\n\n//# sourceURL=webpack:///./src/model.js?");

/***/ })

/******/ });